// Generated by CoffeeScript 1.2.1-pre

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
 
THE GHOST IN THE CSH
 
CoffeeGL JS v0.1

Benjamin Blundell

oni@section9.co.uk

http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
*
*/


(function() {
  var namespace, _setupFrame,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  namespace = function(target, name, block) {
    var item, top, _i, _len, _ref, _ref1;
    if (arguments.length < 3) {
      _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
    }
    top = target;
    _ref1 = name.split('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      target = target[item] || (target[item] = {});
    }
    return block(target, top);
  };

  namespace("CoffeeGL", function(exports) {
    exports.context;
    return exports.app = (function() {

      app.name = 'app';

      function app(element, debug) {
        this.debug = debug != null ? debug : false;
        this.resize = __bind(this.resize, this);

        this.getDelta = __bind(this.getDelta, this);

        this.run = __bind(this.run, this);

        this.totalTime = 0.0;
        this.loops = 0;
        this.skipTicks = 0;
        this.fps = 30;
        this.fullscreen = true;
        this.skipTicks = 1000 / this.fps;
        this.maxFrameSkip = 10;
        this.nextGameTick = (new Date).getTime();
        this.width = 0;
        this.height = 0;
        this.resources = 0;
        this.startTime = Date.now();
        this.oldTime = this.startTime;
        this.canvas = document.getElementById(element);
        if (this.debug) {
          this.gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("experimental-webgl"));
          console.log("CoffeeGL - creating OpenGL debug context");
        } else {
          this.gl = this.canvas.getContext("experimental-webgl");
        }
        exports.context = this;
        window.onEachFrame(this.run);
      }

      app.prototype.run = function() {
        this.resize();
        if (this.resources === 0) return this.draw();
      };

      app.prototype.getDelta = function() {
        var deltaTime;
        deltaTime = Date.now() - this.oldTime;
        this.oldTime = Date.now();
        return deltaTime;
      };

      app.prototype.resize = function() {
        if (this.canvas) {
          if (this.height !== this.canvas.height || this.width !== this.canvas.width) {
            this.height = this.canvas.height;
            this.width = this.canvas.width;
            this.gl.viewportWidth = this.width;
            return this.gl.viewportHeight = this.height;
          }
        }
      };

      app.prototype.draw = function() {
        return 0;
      };

      return app;

    })();
  });

  _setupFrame = function() {
    var onEachFrame;
    if (window.webkitRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return webkitRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else if (window.mozRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return mozRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else {
      onEachFrame = function(cb) {
        return setInterval(cb, 1000 / 60);
      };
    }
    return window.onEachFrame = onEachFrame;
  };

  window.CoffeeGL = CoffeeGL;

  _setupFrame();

  namespace("CoffeeGL", function(exports) {
    return exports.fbo = (function() {

      fbo.name = 'fbo';

      function fbo(size) {
        var gl;
        this.size = size;
        gl = exports.context.gl;
        this.framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        this.framebuffer.width = this.size.x;
        this.framebuffer.height = this.size.y;
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size.x, this.size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.renderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.framebuffer.width, this.framebuffer.height);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
          console.log("Failed to Create Framebuffer!");
        }
      }

      return fbo;

    })();
  });

  namespace("CoffeeGL", function(exports) {
    exports.Vec2 = (function() {
      var name, _fn, _i, _len, _ref;

      Vec2.name = 'Vec2';

      _ref = ['add', 'subtract', 'multiply', 'divide'];
      _fn = function(name) {
        return Vec2[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Vec2.DIM = 2;

      function Vec2(x, y) {
        var _ref1;
        if (x == null) x = 0;
        if (y == null) y = 0;
        _ref1 = [x, y], this.x = _ref1[0], this.y = _ref1[1];
      }

      Vec2.prototype.copy = function() {
        return new Vec2(this.x, this.y);
      };

      Vec2.prototype.length = function() {
        return Math.sqrt(lengthSquared);
      };

      Vec2.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y;
      };

      Vec2.prototype.normalize = function() {
        var m;
        m = this.length;
        if (m > 0) this.divide(m);
        return this;
      };

      Vec2.prototype.subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      };

      Vec2.prototype.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      };

      Vec2.prototype.dv = function(v) {
        return new Vec2(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)));
      };

      Vec2.prototype.dist = function(v) {
        return length(dv(v));
      };

      Vec2.prototype.distSquared = function(v) {
        return lengthSquared(dv(v));
      };

      Vec2.prototype.divide = function(n) {
        var _ref1;
        _ref1 = [this.x / n, this.y / n], this.x = _ref1[0], this.y = _ref1[1];
        return this;
      };

      Vec2.prototype.multiply = function(n) {
        var _ref1;
        _ref1 = [this.x * n, this.y * n], this.x = _ref1[0], this.y = _ref1[1];
        return this;
      };

      Vec2.prototype.equals = function(v) {
        return this.x === v.x && this.x === v.y;
      };

      Vec2.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y;
      };

      Vec2.prototype.invalid = function() {
        return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
      };

      return Vec2;

    })();
    exports.Vec3 = (function() {
      var name, _fn, _i, _len, _ref;

      Vec3.name = 'Vec3';

      _ref = ['add', 'subtract', 'multiply', 'divide'];
      _fn = function(name) {
        return Vec3[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Vec3.DIM = 3;

      function Vec3(x, y, z) {
        var _ref1;
        if (x == null) x = 0;
        if (y == null) y = 0;
        if (z == null) z = 0;
        _ref1 = [x, y, z], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2];
      }

      Vec3.prototype.copy = function() {
        return new Vec3(this.x, this.y, this.z);
      };

      Vec3.prototype.length = function() {
        return Math.sqrt(lengthSquared);
      };

      Vec3.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      };

      Vec3.prototype.normalize = function() {
        var m;
        m = this.length;
        if (m > 0) this.divide(m);
        return this;
      };

      Vec3.prototype.subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      };

      Vec3.prototype.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      };

      Vec3.prototype.dv = function(v) {
        return new Vec3(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z))));
      };

      Vec3.prototype.dist = function(v) {
        return length(dv(v));
      };

      Vec3.prototype.distSquared = function(v) {
        return lengthSquared(dv(v));
      };

      Vec3.prototype.divide = function(n) {
        var _ref1;
        _ref1 = [this.x / n, this.y / n, this.z / n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2];
        return this;
      };

      Vec3.prototype.multiply = function(n) {
        var _ref1;
        _ref1 = [this.x * n, this.y * n, this.z * n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2];
        return this;
      };

      Vec3.prototype.equals = function(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z;
      };

      Vec3.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };

      Vec3.prototype.invalid = function() {
        return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z);
      };

      return Vec3;

    })();
    exports.Vec4 = (function() {
      var name, _fn, _i, _len, _ref;

      Vec4.name = 'Vec4';

      _ref = ['add', 'subtract', 'multiply', 'divide'];
      _fn = function(name) {
        return Vec4[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Vec4.DIM = 4;

      function Vec4(x, y, z, w) {
        var _ref1;
        if (x == null) x = 0;
        if (y == null) y = 0;
        if (z == null) z = 0;
        if (w == null) w = 1;
        _ref1 = [x, y, z, w], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2], this.w = _ref1[3];
      }

      Vec4.prototype.copy = function() {
        return new Vec4(this.x, this.y, this.z, this.w);
      };

      Vec4.prototype.length = function() {
        return Math.sqrt(lengthSquared);
      };

      Vec4.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      };

      Vec4.prototype.normalize = function() {
        var m;
        m = this.length;
        if (m > 0) this.divide(m);
        return this;
      };

      Vec4.prototype.subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      };

      Vec4.prototype.equals = function(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
      };

      Vec4.prototype.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      };

      Vec4.prototype.dv = function(v) {
        return new Vec4(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z)(Math.abs(this.w - v.w)))));
      };

      Vec4.prototype.dist = function(v) {
        return length(dv(v));
      };

      Vec4.prototype.distSquared = function(v) {
        return lengthSquared(dv(v));
      };

      Vec4.prototype.divide = function(n) {
        var _ref1;
        _ref1 = [this.x / n, this.y / n, this.z / n, this.w / n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2], this.w = _ref1[3];
        return this;
      };

      Vec4.prototype.multiply = function(n) {
        var _ref1;
        _ref1 = [this.x * n, this.y * n, this.z * n, this.w * n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2], this.w = _ref1[3];
        return this;
      };

      Vec4.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      };

      Vec4.prototype.invalid = function() {
        return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z) || this.w === Infinity || isNaN(this.w);
      };

      return Vec4;

    })();
    return exports.Matrix4 = (function() {
      var name, _fn, _i, _len, _ref;

      Matrix4.name = 'Matrix4';

      _ref = ['add', 'subtract', 'multiply', 'divide', 'addScalar', 'subtractScalar', 'multiplyScalar', 'divideScalar'];
      _fn = function(name) {
        return Matrix4[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Matrix4.DIM = 4;

      function Matrix4(a) {
        this.a = a;
      }

      Matrix4.prototype.multiplyScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num * n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.addScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num + n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.subtractScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num - n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.divideScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num / n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.setToIdentity = function() {
        return this.a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      };

      Matrix4.prototype.multiply = function(m) {
        this.a[0] = this.a[0] * m.a[0] + this.a[4] * m.a[1] + this.a[8] * m.a[2] + this.a[12] * m.a[3];
        this.a[1] = this.a[1] * m.a[0] + this.a[5] * m.a[1] + this.a[9] * m.a[2] + this.a[13] * m.a[3];
        this.a[2] = this.a[2] * m.a[0] + this.a[6] * m.a[1] + this.a[10] * m.a[2] + this.a[14] * m.a[3];
        this.a[3] = this.a[3] * m.a[0] + this.a[7] * m.a[1] + this.a[11] * m.a[2] + this.a[15] * m.a[3];
        this.a[4] = this.a[0] * m.a[4] + this.a[4] * m.a[5] + this.a[8] * m.a[6] + this.a[12] * m.a[7];
        this.a[5] = this.a[1] * m.a[4] + this.a[5] * m.a[5] + this.a[9] * m.a[6] + this.a[13] * m.a[7];
        this.a[6] = this.a[2] * m.a[4] + this.a[6] * m.a[5] + this.a[10] * m.a[6] + this.a[14] * m.a[7];
        this.a[7] = this.a[3] * m.a[4] + this.a[7] * m.a[5] + this.a[11] * m.a[6] + this.a[15] * m.a[7];
        this.a[8] = this.a[0] * m.a[8] + this.a[4] * m.a[9] + this.a[8] * m.a[10] + this.a[12] * m.a[11];
        this.a[9] = this.a[1] * m.a[8] + this.a[5] * m.a[9] + this.a[9] * m.a[10] + this.a[13] * m.a[11];
        this.a[10] = this.a[2] * m.a[8] + this.a[6] * m.a[9] + this.a[10] * m.a[10] + this.a[14] * m.a[11];
        this.a[11] = this.a[3] * m.a[8] + this.a[7] * m.a[9] + this.a[11] * m.a[10] + this.a[15] * m.a[11];
        this.a[12] = this.a[0] * m.a[12] + this.a[4] * m.a[13] + this.a[8] * m.a[14] + this.a[12] * m.a[15];
        this.a[13] = this.a[1] * m.a[12] + this.a[5] * m.a[13] + this.a[9] * m.a[14] + this.a[13] * m.a[15];
        this.a[14] = this.a[2] * m.a[12] + this.a[6] * m.a[13] + this.a[10] * m.a[14] + this.a[14] * m.a[15];
        return this.a[15] = this.a[3] * m.a[12] + this.a[7] * m.a[13] + this.a[11] * m.a[14] + this.a[15] * m.a[15];
      };

      Matrix4.prototype.multiplyVec3 = function(v) {
        var w, x, y, z;
        x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12];
        y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13];
        z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14];
        w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15];
        return new Vec3(x / w(y / w(z / w)));
      };

      Matrix4.prototype.multiplyVec4 = function(v) {
        var w, x, y, z;
        x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12] * v.w;
        y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13] * v.w;
        z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14] * v.w;
        w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15] * v.w;
        return new Vec4(x(y(z(w))));
      };

      Matrix4.prototype.at = function(r, c) {
        return this.a[c * Matrix4.DIM + r];
      };

      Matrix4.prototype.getCol = function(c) {
        c = c * Matrix4.DIM;
        return Vec4(this.a[c + 0](this.a[c + 1](this.a[c + 2](this.a[c + 3]))));
      };

      Matrix4.prototype.getRow = function(r) {
        return Vec4(this.a[r + 0](this.a[r + 4](this.a[r + 8](this.a[r + 12]))));
      };

      return Matrix4;

    })();
  });

  namespace("CoffeeGL", function(exports) {
    exports.shader = (function() {

      shader.name = 'shader';

      function shader(sv, sf, sg) {
        var gl;
        this.sv = sv;
        this.sf = sf;
        this.sg = sg != null ? sg : null;
        gl = exports.context.gl;
        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
        if (this.vertexShader) {
          gl.shaderSource(this.vertexShader, this.sv);
          gl.compileShader(this.vertexShader);
          if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
            console.log("CoffeeGL Error - Could not compile vertex shader");
          }
        } else {
          console.log("CoffeeGL Error - No vertex shader object could be created");
        }
        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        if (this.fragmentShader) {
          gl.shaderSource(this.fragmentShader, this.sf);
          gl.compileShader(this.fragmentShader);
          if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
            console.log("CoffeeGL Error - Could not compile fragment shader");
          }
        } else {
          console.log("CoffeeGL Error - No Fragment shader object could be created");
        }
        this.shaderProgram = gl.createProgram();
      }

      shader.prototype.bind = function() {
        var gl;
        gl = exports.context.gl;
        gl.attachShader(this.shaderProgram, this.vertexShader);
        gl.attachShader(this.shaderProgram, this.fragmentShader);
        gl.linkProgram(this.shaderProgram);
        return gl.useProgram(this.shaderProgram);
      };

      shader.prototype.unbind = function() {
        var gl;
        gl = exports.context.gl;
        gl.detachShader(this.shaderProgram, this.vertexShader);
        gl.detachShader(this.shaderProgram, this.fragmentShader);
        return gl.useProgram(null);
      };

      shader.prototype.setUniform3f = function(name, a, b, c) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform3f(uniform, a, b, c);
      };

      shader.prototype.setUniform3v = function(name, v) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform3f(uniform, v.x, v.y, v.z);
      };

      shader.prototype.setUniform4f = function(name, a, b, c, d) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform4f(uniform, a, b, c, d);
      };

      shader.prototype.setUniform4v = function(name, v) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform4f(uniform, v.x, v.y, v.z, v.w);
      };

      return shader;

    })();
    exports.shader.basic = (function(_super) {

      __extends(basic, _super);

      basic.name = 'basic';

      function basic() {
        this.sv = "attribute vec3 aVertexPosition;attribute vec4 aVertexColour;attribute vec3 aVertexNormal;uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix;uniform mat4 uNormalMatrix;varying vec4 vColor;varying vec4 vTransformedNormal;void main(void) {	gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);	vColor = aVertexColour;	vTransformedNormal =  uNormalMatrix * vec4(aVertexNormal, 1.0);}";
        this.sf = "#ifdef GL_ES precision highp float; #endifvarying vec4 vColor;void main(void) { gl_FragColor = vColor; }";
        basic.__super__.constructor.call(this, this.sv, this.sf);
      }

      return basic;

    })(exports.shader);
    return exports.shader.lighting = (function(_super) {

      __extends(lighting, _super);

      lighting.name = 'lighting';

      function lighting() {
        this.sv = "attribute vec3 aVertexPosition;attribute vec3 aVertexNormal;attribute vec2 aTextureCoord;uniform mat4 uModelViewMatrix;uniform mat4 uProjectionMatrix;uniform mat4 uNormalMatrix;varying vec2 vTextureCoord;varying vec4 vTransformedNormal;varying vec4 vPosition;void main(void) {    vPosition = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);    gl_Position =  vPosition;    vTextureCoord = aTextureCoord;    vTransformedNormal = uModelViewMatrix * vec4(aVertexNormal, 1.0);}";
        this.sf = "#ifdef GL_ESprecision highp float;#endifvarying vec2 vTextureCoord;varying vec4 vTransformedNormal;varying vec4 vPosition;uniform vec3 uMaterialAmbientColor;uniform vec3 uMaterialDiffuseColor;uniform vec3 uMaterialSpecularColor;uniform float uMaterialShininess;uniform vec3 uMaterialEmissiveColor;uniform vec3 uAmbientLightingColor;uniform vec3 uPointLightingLocation;uniform vec3 uPointLightingDiffuseColor;uniform vec3 uPointLightingSpecularColor;uniform sampler2D uSampler;void main(void) {    vec3 ambientLightWeighting = uAmbientLightingColor;    vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);    vec3 normal = normalize(vTransformedNormal.xyz);    vec3 specularLightWeighting = vec3(0.0, 0.0, 0.0);//    vec3 eyeDirection = normalize(-vPosition.xyz);	vec3 eyeDirection = vec3(0,0,-1);    vec3 reflectionDirection = reflect(-lightDirection, normal);    float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);    specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;    float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);    vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;        vec3 materialAmbientColor = uMaterialAmbientColor;    vec3 materialDiffuseColor = uMaterialDiffuseColor;    vec3 materialSpecularColor = uMaterialSpecularColor;    vec3 materialEmissiveColor = uMaterialEmissiveColor;    float alpha = 1.0;    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));    materialAmbientColor = materialAmbientColor * textureColor.rgb;    materialDiffuseColor = materialDiffuseColor * textureColor.rgb;    materialEmissiveColor = materialEmissiveColor * textureColor.rgb;    alpha = textureColor.a;     gl_FragColor = vec4(      materialAmbientColor * ambientLightWeighting      + materialDiffuseColor * diffuseLightWeighting      + materialSpecularColor * specularLightWeighting      + materialEmissiveColor,      alpha    );}";
      }

      return lighting;

    })(exports.shader);
  });

}).call(this);
