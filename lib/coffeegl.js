// Generated by CoffeeScript 1.2.1-pre

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
 
THE GHOST IN THE CSH
 
CoffeeGL JS v0.1

Benjamin Blundell

oni@section9.co.uk

http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
*
*/


(function() {
  var namespace, _setupFrame,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  namespace = function(target, name, block) {
    var item, top, _i, _len, _ref, _ref1;
    if (arguments.length < 3) {
      _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
    }
    top = target;
    _ref1 = name.split('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      target = target[item] || (target[item] = {});
    }
    return block(target, top);
  };

  namespace("CoffeeGL", function(exports) {
    exports.context;
    return exports.App = (function() {

      App.name = 'App';

      function App(element, debug) {
        this.debug = debug != null ? debug : false;
        this.resize = __bind(this.resize, this);

        this.getDelta = __bind(this.getDelta, this);

        this.run = __bind(this.run, this);

        this.totalTime = 0.0;
        this.loops = 0;
        this.skipTicks = 0;
        this.fps = 30;
        this.fullscreen = true;
        this.skipTicks = 1000 / this.fps;
        this.maxFrameSkip = 10;
        this.nextGameTick = (new Date).getTime();
        this.width = 0;
        this.height = 0;
        this.resources = 0;
        this.startTime = Date.now();
        this.oldTime = this.startTime;
        this.canvas = document.getElementById(element);
        this.modelViewMatrix = [];
        this.perspectiveMatrix = [];
        this.modelViewMatrix.push(new exports.Matrix4());
        this.perspectiveMatrix.push(new exports.Matrix4());
        if (this.debug) {
          this.gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("experimental-webgl"));
          console.log("CoffeeGL - creating OpenGL debug context");
        } else {
          this.gl = this.canvas.getContext("experimental-webgl");
        }
        exports.context = this;
        window.onEachFrame(this.run);
      }

      App.prototype.run = function() {
        this.resize();
        if (this.resources === 0) return this.draw();
      };

      App.prototype.getDelta = function() {
        var deltaTime;
        deltaTime = Date.now() - this.oldTime;
        this.oldTime = Date.now();
        return deltaTime;
      };

      App.prototype.resize = function() {
        if (this.canvas) {
          if (this.height !== this.canvas.height || this.width !== this.canvas.width) {
            this.height = this.canvas.height;
            this.width = this.canvas.width;
            this.gl.viewportWidth = this.width;
            return this.gl.viewportHeight = this.height;
          }
        }
      };

      App.prototype.draw = function() {
        return 0;
      };

      App.prototype.pushMatrix = function() {
        var m;
        m = modelViewMatrix[modelViewMatrix.length - 1].dup();
        return modelViewMatrix.push(m);
      };

      App.prototype.popMatrix = function() {
        return modelViewMatrix.pop();
      };

      App.prototype.translate = function(v) {
        var m;
        m = modelViewMatrix[modelViewMatrix.length - 1];
        m.a[12] += v.x;
        m.a[13] += v.y;
        m.a[14] += v.z;
        return m;
      };

      App.prototype.rotate = function(a, v) {
        var m, r;
        a = exports.degToRad(a);
        m = modelViewMatrix[modelViewMatrix.length - 1];
        r = new Matrix4();
        r.a[0] = Math.cos(a) + (v.x * v.x) * (1 - Math.cos(a));
        r.a[1] = (v.y * v.x) * (1 - Math.cos(a)) + v.z * Math.sin(a);
        r.a[2] = (v.z * v.x) * (1 - Math.cos(a)) - v.y * Math.sin(a);
        r.a[4] = (v.x * v.y) * (1 - Math.cos(a)) - v.z * Math.sin(a);
        r.a[5] = Math.cos(a) + (v.y * v.y) * (1 - Math.cos(a));
        r.a[6] = (v.z * v.y) * (1 - Math.cos(a)) - v.x * Math.sin(a);
        r.a[8] = (v.z * v.x) * (1 - Math.cos(a)) - v.y * Math.sin(a);
        r.a[9] = (v.z * v.y) * (1 - Math.cos(a)) + v.x * Math.sin(a);
        r.a[10] = Math.cos(a) + (v.z * v.z) * (1 - Math.cos(a));
        return m.toMultiply(r);
      };

      App.prototype.scale = function(v) {
        var m;
        m = modelViewMatrix[modelViewMatrix.length - 1];
        m.a[0] *= v.x;
        m.a[5] *= v.y;
        m.a[10] *= v.z;
        return m;
      };

      return App;

    })();
  });

  _setupFrame = function() {
    var onEachFrame;
    if (window.webkitRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return webkitRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else if (window.mozRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return mozRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else {
      onEachFrame = function(cb) {
        return setInterval(cb, 1000 / 60);
      };
    }
    return window.onEachFrame = onEachFrame;
  };

  window.CoffeeGL = CoffeeGL;

  _setupFrame();

  namespace("CoffeeGL", function(exports) {
    return exports.Fbo = (function() {

      Fbo.name = 'Fbo';

      function Fbo(size) {
        var gl;
        this.size = size;
        gl = exports.context.gl;
        this.framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        this.framebuffer.width = this.size.x;
        this.framebuffer.height = this.size.y;
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size.x, this.size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.renderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.framebuffer.width, this.framebuffer.height);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
          console.log("Failed to Create Framebuffer!");
        }
      }

      return Fbo;

    })();
  });

  namespace("CoffeeGL", function(exports) {
    exports.Vec2 = (function() {
      var name, _fn, _i, _len, _ref;

      Vec2.name = 'Vec2';

      _ref = ['add', 'subtract', 'multiply', 'divide', 'normalize'];
      _fn = function(name) {
        return Vec2[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Vec2.DIM = 2;

      function Vec2(x, y) {
        var _ref1;
        if (x == null) x = 0;
        if (y == null) y = 0;
        _ref1 = [x, y], this.x = _ref1[0], this.y = _ref1[1];
      }

      Vec2.prototype.copy = function() {
        return new Vec2(this.x, this.y);
      };

      Vec2.prototype.length = function() {
        return Math.sqrt(lengthSquared);
      };

      Vec2.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y;
      };

      Vec2.prototype.normalize = function() {
        var m;
        m = this.length;
        if (m > 0) this.divide(m);
        return this;
      };

      Vec2.prototype.toNormal = function() {
        var m;
        m = this.length;
        if (m > 0) return this.divide(m);
      };

      Vec2.prototype.subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      };

      Vec2.prototype.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      };

      Vec2.prototype.dv = function(v) {
        return new Vec2(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)));
      };

      Vec2.prototype.dist = function(v) {
        return length(dv(v));
      };

      Vec2.prototype.distSquared = function(v) {
        return lengthSquared(dv(v));
      };

      Vec2.prototype.divide = function(n) {
        var _ref1;
        _ref1 = [this.x / n, this.y / n], this.x = _ref1[0], this.y = _ref1[1];
        return this;
      };

      Vec2.prototype.multiply = function(n) {
        var _ref1;
        _ref1 = [this.x * n, this.y * n], this.x = _ref1[0], this.y = _ref1[1];
        return this;
      };

      Vec2.prototype.equals = function(v) {
        return this.x === v.x && this.x === v.y;
      };

      Vec2.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y;
      };

      Vec2.prototype.invalid = function() {
        return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
      };

      return Vec2;

    })();
    exports.Vec3 = (function() {
      var name, _fn, _i, _len, _ref;

      Vec3.name = 'Vec3';

      _ref = ['add', 'subtract', 'multiply', 'divide', 'normalize'];
      _fn = function(name) {
        return Vec3[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Vec3.DIM = 3;

      function Vec3(x, y, z) {
        var _ref1;
        if (x == null) x = 0;
        if (y == null) y = 0;
        if (z == null) z = 0;
        _ref1 = [x, y, z], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2];
      }

      Vec3.prototype.copy = function() {
        return new Vec3(this.x, this.y, this.z);
      };

      Vec3.prototype.length = function() {
        return Math.sqrt(lengthSquared);
      };

      Vec3.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      };

      Vec3.prototype.normalize = function() {
        var m;
        m = this.length;
        if (m > 0) this.divide(m);
        return this;
      };

      Vec3.prototype.toNormal = function() {
        var m;
        m = this.length;
        if (m > 0) return this.divide(m);
      };

      Vec3.prototype.subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      };

      Vec3.prototype.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      };

      Vec3.prototype.dv = function(v) {
        return new Vec3(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z))));
      };

      Vec3.prototype.dist = function(v) {
        return length(dv(v));
      };

      Vec3.prototype.distSquared = function(v) {
        return lengthSquared(dv(v));
      };

      Vec3.prototype.divide = function(n) {
        var _ref1;
        _ref1 = [this.x / n, this.y / n, this.z / n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2];
        return this;
      };

      Vec3.prototype.multiply = function(n) {
        var _ref1;
        _ref1 = [this.x * n, this.y * n, this.z * n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2];
        return this;
      };

      Vec3.prototype.equals = function(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z;
      };

      Vec3.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      };

      Vec3.prototype.invalid = function() {
        return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z);
      };

      return Vec3;

    })();
    exports.Vec4 = (function() {
      var name, _fn, _i, _len, _ref;

      Vec4.name = 'Vec4';

      _ref = ['add', 'subtract', 'multiply', 'divide', 'normalize'];
      _fn = function(name) {
        return Vec4[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Vec4.DIM = 4;

      function Vec4(x, y, z, w) {
        var _ref1;
        if (x == null) x = 0;
        if (y == null) y = 0;
        if (z == null) z = 0;
        if (w == null) w = 1;
        _ref1 = [x, y, z, w], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2], this.w = _ref1[3];
      }

      Vec4.prototype.copy = function() {
        return new Vec4(this.x, this.y, this.z, this.w);
      };

      Vec4.prototype.length = function() {
        return Math.sqrt(lengthSquared);
      };

      Vec4.prototype.lengthSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      };

      Vec4.prototype.normalize = function() {
        var m;
        m = this.length;
        if (m > 0) this.divide(m);
        return this;
      };

      Vec4.prototype.toNormal = function() {
        var m;
        m = this.length;
        if (m > 0) return this.divide(m);
      };

      Vec4.prototype.subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      };

      Vec4.prototype.equals = function(v) {
        return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
      };

      Vec4.prototype.add = function(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      };

      Vec4.prototype.dv = function(v) {
        return new Vec4(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z)(Math.abs(this.w - v.w)))));
      };

      Vec4.prototype.dist = function(v) {
        return length(dv(v));
      };

      Vec4.prototype.distSquared = function(v) {
        return lengthSquared(dv(v));
      };

      Vec4.prototype.divide = function(n) {
        var _ref1;
        _ref1 = [this.x / n, this.y / n, this.z / n, this.w / n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2], this.w = _ref1[3];
        return this;
      };

      Vec4.prototype.multiply = function(n) {
        var _ref1;
        _ref1 = [this.x * n, this.y * n, this.z * n, this.w * n], this.x = _ref1[0], this.y = _ref1[1], this.z = _ref1[2], this.w = _ref1[3];
        return this;
      };

      Vec4.prototype.dot = function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      };

      Vec4.prototype.invalid = function() {
        return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z) || this.w === Infinity || isNaN(this.w);
      };

      return Vec4;

    })();
    exports.Matrix4 = (function() {
      var name, _fn, _i, _len, _ref;

      Matrix4.name = 'Matrix4';

      _ref = ['add', 'subtract', 'multiply', 'divide', 'addScalar', 'subtractScalar', 'multiplyScalar', 'divideScalar', 'translate'];
      _fn = function(name) {
        return Matrix4[name] = function(a, b) {
          return a.copy()[name](b);
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        _fn(name);
      }

      Matrix4.DIM = 4;

      function Matrix4(a) {
        this.a = a != null ? a : [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      Matrix4.prototype.dup = function() {
        return new Matrix4(this.a);
      };

      Matrix4.prototype.multiplyScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num * n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.addScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num + n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.subtractScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num - n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.divideScalar = function(n) {
        var num;
        return this.a = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.a;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            num = _ref1[_j];
            _results.push(num / n);
          }
          return _results;
        }).call(this);
      };

      Matrix4.prototype.setToIdentity = function() {
        return this.a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      };

      Matrix4.prototype.multiply = function(m) {
        return toMultiply(m);
      };

      Matrix4.prototype.toMultiply = function(m) {
        this.a[0] = this.a[0] * m.a[0] + this.a[4] * m.a[1] + this.a[8] * m.a[2] + this.a[12] * m.a[3];
        this.a[1] = this.a[1] * m.a[0] + this.a[5] * m.a[1] + this.a[9] * m.a[2] + this.a[13] * m.a[3];
        this.a[2] = this.a[2] * m.a[0] + this.a[6] * m.a[1] + this.a[10] * m.a[2] + this.a[14] * m.a[3];
        this.a[3] = this.a[3] * m.a[0] + this.a[7] * m.a[1] + this.a[11] * m.a[2] + this.a[15] * m.a[3];
        this.a[4] = this.a[0] * m.a[4] + this.a[4] * m.a[5] + this.a[8] * m.a[6] + this.a[12] * m.a[7];
        this.a[5] = this.a[1] * m.a[4] + this.a[5] * m.a[5] + this.a[9] * m.a[6] + this.a[13] * m.a[7];
        this.a[6] = this.a[2] * m.a[4] + this.a[6] * m.a[5] + this.a[10] * m.a[6] + this.a[14] * m.a[7];
        this.a[7] = this.a[3] * m.a[4] + this.a[7] * m.a[5] + this.a[11] * m.a[6] + this.a[15] * m.a[7];
        this.a[8] = this.a[0] * m.a[8] + this.a[4] * m.a[9] + this.a[8] * m.a[10] + this.a[12] * m.a[11];
        this.a[9] = this.a[1] * m.a[8] + this.a[5] * m.a[9] + this.a[9] * m.a[10] + this.a[13] * m.a[11];
        this.a[10] = this.a[2] * m.a[8] + this.a[6] * m.a[9] + this.a[10] * m.a[10] + this.a[14] * m.a[11];
        this.a[11] = this.a[3] * m.a[8] + this.a[7] * m.a[9] + this.a[11] * m.a[10] + this.a[15] * m.a[11];
        this.a[12] = this.a[0] * m.a[12] + this.a[4] * m.a[13] + this.a[8] * m.a[14] + this.a[12] * m.a[15];
        this.a[13] = this.a[1] * m.a[12] + this.a[5] * m.a[13] + this.a[9] * m.a[14] + this.a[13] * m.a[15];
        this.a[14] = this.a[2] * m.a[12] + this.a[6] * m.a[13] + this.a[10] * m.a[14] + this.a[14] * m.a[15];
        return this.a[15] = this.a[3] * m.a[12] + this.a[7] * m.a[13] + this.a[11] * m.a[14] + this.a[15] * m.a[15];
      };

      Matrix4.prototype.multiplyVec3 = function(v) {
        var w, x, y, z;
        x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12];
        y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13];
        z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14];
        w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15];
        return new Vec3(x / w(y / w(z / w)));
      };

      Matrix4.prototype.multiplyVec4 = function(v) {
        var w, x, y, z;
        x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12] * v.w;
        y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13] * v.w;
        z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14] * v.w;
        w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15] * v.w;
        return new Vec4(x(y(z(w))));
      };

      Matrix4.prototype.at = function(r, c) {
        return this.a[c * Matrix4.DIM + r];
      };

      Matrix4.prototype.getCol = function(c) {
        c = c * Matrix4.DIM;
        return Vec4(this.a[c + 0](this.a[c + 1](this.a[c + 2](this.a[c + 3]))));
      };

      Matrix4.prototype.getRow = function(r) {
        return Vec4(this.a[r + 0](this.a[r + 4](this.a[r + 8](this.a[r + 12]))));
      };

      Matrix4.prototype.inverse = function() {};

      Matrix4.prototype.transpose = function() {
        return new Matrix4([this.a[0], this.a[4], this.a[8], this.a[12], this.a[1], this.a[5], this.a[9], this.a[13], this.a[2], this.a[6], this.a[10], this.a[14], this.a[3], this.a[7], this.a[11], this.a[15]]);
      };

      Matrix4.prototype.translate = function(v) {
        if (v.DIM === 3 || v.DIM === 4) {
          this.a[12] += v.x;
          this.a[13] += v.y;
          return this.a[14] += v.z;
        } else {
          return console.log("CoffeeGL Error - Mismatched vector and matrix dimensions");
        }
      };

      Matrix4.prototype.print = function() {
        console.log(a[0] + "," + a[4] + "," + a[8] + "," + a[12]);
        console.log(a[1] + "," + a[5] + "," + a[9] + "," + a[13]);
        console.log(a[2] + "," + a[6] + "," + a[10] + "," + a[14]);
        return console.log(a[3] + "," + a[7] + "," + a[11] + "," + a[15]);
      };

      Matrix4.prototype.lookAt = function(eye, look, up) {
        var m, t, x, y, z;
        z = eye.subtract().toNormal();
        x = up.cross(z).toNormal();
        y = z.cross(x).toNormal();
        m = new Matrix4([x.x, x.y, x.z, 0, y.x, y.y, y.z, 0, z.x, z.y, z.z, 0, 0, 0, 0, 1]);
        t = new Matrix4([1, 0, 0, -eye.x, 0, 1, 0, -eye.y, 0, 0, 1, -eye.z, 0, 0, 0, 1]);
        return m.multiply(t);
      };

      Matrix4.prototype.makePerspective = function(fovy, aspect, znear, zfar) {
        var xmax, xmin, ymax, ymin;
        ymax = znear * Math.tan(fovy * Math.PI / 360.0);
        ymin = -ymax;
        xmin = ymin * aspect;
        xmax = ymax * aspect;
        return makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
      };

      Matrix4.prototype.makeFrustum = function(left, right, bottom, top, znear, zfar) {
        var a, b, c, d, x, y;
        x = 2 * znear / (right - left);
        y = 2 * znear / (top - bottom);
        a = (right + left) / (right - left);
        b = (top + bottom) / (top - bottom);
        c = -(zfar + znear) / (zfar - znear);
        d = -2 * zfar * znear / (zfar - znear);
        return new Matrix4([x, 0, 0, 0, 0, y, 0, 0, a, b, c, -1, 0, 0, d, 0]);
      };

      Matrix4.prototype.makeOrtho = function(left, right, bottom, top, znear, zfar) {
        var tx, ty, tz;
        tx = -(right + left) / (right - left);
        ty = -(top + bottom) / (top - bottom);
        tz = -(zfar + znear) / (zfar - znear);
        return new Matrix4([2 / (right - left), 0, 0, tx, 0, 2 / (top - bottom), 0, ty, 0, 0, -2 / (zfar - znear), tz, 0, 0, 0, 1]);
      };

      return Matrix4;

    })();
    exports.radToDeg = function(a) {
      return a * 57.2957795;
    };
    return exports.degToRad = function(a) {
      return a * 0.017453292523928;
    };
  });

  namespace("CoffeeGL", function(exports) {
    exports.Shader = (function() {

      Shader.name = 'Shader';

      function Shader(sv, sf, sg) {
        var gl;
        this.sv = sv;
        this.sf = sf;
        this.sg = sg != null ? sg : null;
        gl = exports.context.gl;
        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
        if (!this.vertexShader) {
          console.log("CoffeeGL Error - No vertex shader object could be created");
        }
        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        if (!this.fragmentShader) {
          console.log("CoffeeGL Error - No Fragment shader object could be created");
        }
        compile(this.sv, this.sf, this.sg);
        this.shaderProgram = gl.createProgram();
      }

      Shader.prototype.compile = function(sv, sf, sg) {
        var gl;
        gl = exports.context.gl;
        this.sv = sv;
        this.sf = sf;
        this.sg = sg;
        gl.shaderSource(this.vertexShader, this.sv);
        gl.compileShader(this.vertexShader);
        if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
          console.log("CoffeeGL Error - Could not compile vertex shader");
        }
        gl.shaderSource(this.fragmentShader, this.sf);
        gl.compileShader(this.fragmentShader);
        if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
          return console.log("CoffeeGL Error - Could not compile fragment shader");
        }
      };

      Shader.prototype.bind = function() {
        var gl;
        gl = exports.context.gl;
        gl.attachShader(this.shaderProgram, this.vertexShader);
        gl.attachShader(this.shaderProgram, this.fragmentShader);
        gl.linkProgram(this.shaderProgram);
        return gl.useProgram(this.shaderProgram);
      };

      Shader.prototype.unbind = function() {
        var gl;
        gl = exports.context.gl;
        gl.detachShader(this.shaderProgram, this.vertexShader);
        gl.detachShader(this.shaderProgram, this.fragmentShader);
        return gl.useProgram(null);
      };

      Shader.prototype.setUniform3f = function(name, a, b, c) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform3f(uniform, a, b, c);
      };

      Shader.prototype.setUniform3v = function(name, v) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform3f(uniform, v.x, v.y, v.z);
      };

      Shader.prototype.setUniform4f = function(name, a, b, c, d) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform4f(uniform, a, b, c, d);
      };

      Shader.prototype.setUniform4v = function(name, v) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform4f(uniform, v.x, v.y, v.z, v.w);
      };

      Shader.prototype.setUniform1f = function(name, a) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform1f(uniform, a);
      };

      Shader.prototype.setUniform1i = function(name, a) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniform1i(uniform, a);
      };

      Shader.prototype.setMatrix4f = function(name, m) {
        var gl, uniform;
        gl = exports.context.gl;
        uniform = gl.getUniformLocation(this.shaderProgram, name);
        return gl.uniformMatrix4fv(uniform, false, new Float32Array(m.a));
      };

      Shader.prototype.enableAttribArray = function(name) {
        var gl, position;
        gl = exports.context.gl;
        position = gl.getAttribLocation(this.shaderProgram, name);
        return gl.enableVertexAttribArray(position);
      };

      Shader.prototype.getAttribArray = function(name) {
        var gl;
        gl = exports.context.gl;
        return gl.getAttribLocation(this.shaderProgram, name);
      };

      return Shader;

    })();
    exports.Shader.Basic = (function(_super) {

      __extends(Basic, _super);

      Basic.name = 'Basic';

      function Basic() {
        this.sv = "attribute vec3 aVertexPosition;attribute vec4 aVertexColour;attribute vec3 aVertexNormal;uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix;uniform mat4 uNormalMatrix;varying vec4 vColor;varying vec4 vTransformedNormal;void main(void) {	gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);	vColor = aVertexColour;	vTransformedNormal =  uNormalMatrix * vec4(aVertexNormal, 1.0);}";
        this.sf = "#ifdef GL_ES precision highp float; #endifvarying vec4 vColor;void main(void) { gl_FragColor = vColor; }";
        Basic.__super__.constructor.call(this, this.sv, this.sf);
      }

      return Basic;

    })(exports.Shader);
    return exports.Shader.Lighting = (function(_super) {

      __extends(Lighting, _super);

      Lighting.name = 'Lighting';

      function Lighting() {
        this.sv = "attribute vec3 aVertexPosition;attribute vec3 aVertexNormal;attribute vec2 aTextureCoord;uniform mat4 uModelViewMatrix;uniform mat4 uProjectionMatrix;uniform mat4 uNormalMatrix;varying vec2 vTextureCoord;varying vec4 vTransformedNormal;varying vec4 vPosition;void main(void) {    vPosition = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);    gl_Position =  vPosition;    vTextureCoord = aTextureCoord;    vTransformedNormal = uModelViewMatrix * vec4(aVertexNormal, 1.0);}";
        this.sf = "#ifdef GL_ESprecision highp float;#endifvarying vec2 vTextureCoord;varying vec4 vTransformedNormal;varying vec4 vPosition;uniform vec3 uMaterialAmbientColor;uniform vec3 uMaterialDiffuseColor;uniform vec3 uMaterialSpecularColor;uniform float uMaterialShininess;uniform vec3 uMaterialEmissiveColor;uniform vec3 uAmbientLightingColor;uniform vec3 uPointLightingLocation;uniform vec3 uPointLightingDiffuseColor;uniform vec3 uPointLightingSpecularColor;uniform sampler2D uSampler;void main(void) {    vec3 ambientLightWeighting = uAmbientLightingColor;    vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);    vec3 normal = normalize(vTransformedNormal.xyz);    vec3 specularLightWeighting = vec3(0.0, 0.0, 0.0);//    vec3 eyeDirection = normalize(-vPosition.xyz);	vec3 eyeDirection = vec3(0,0,-1);    vec3 reflectionDirection = reflect(-lightDirection, normal);    float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);    specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;    float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);    vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;        vec3 materialAmbientColor = uMaterialAmbientColor;    vec3 materialDiffuseColor = uMaterialDiffuseColor;    vec3 materialSpecularColor = uMaterialSpecularColor;    vec3 materialEmissiveColor = uMaterialEmissiveColor;    float alpha = 1.0;    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));    materialAmbientColor = materialAmbientColor * textureColor.rgb;    materialDiffuseColor = materialDiffuseColor * textureColor.rgb;    materialEmissiveColor = materialEmissiveColor * textureColor.rgb;    alpha = textureColor.a;     gl_FragColor = vec4(      materialAmbientColor * ambientLightWeighting      + materialDiffuseColor * diffuseLightWeighting      + materialSpecularColor * specularLightWeighting      + materialEmissiveColor,      alpha    );}";
      }

      return Lighting;

    })(exports.Shader);
  });

  namespace("CoffeeGL", function(exports) {
    exports.Texture = (function() {

      Texture.name = 'Texture';

      function Texture(path) {
        var gl,
          _this = this;
        this.path = path;
        gl = exports.context.gl;
        this.texImage = new Image();
        this.texture = gl.createTexture();
        this.texture.image = this.texImage;
        this.texImage.src = this.path;
        exports.context.resources++;
        this.texImage.onload = function() {
          exports.context.resources--;
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.bindTexture(gl.TEXTURE_2D, _this.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _this.texture.image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.generateMipmap(gl.TEXTURE_2D);
          return gl.bindTexture(gl.TEXTURE_2D, null);
        };
      }

      Texture.prototype.bind = function() {
        var gl;
        gl = exports.context.gl;
        return gl.bindTexture(gl.TEXTURE_2D, this.texture);
      };

      Texture.prototype.unbind = function() {
        var gl;
        gl = exports.context.gl;
        return gl.bindTexture(gl.TEXTURE_2D, null);
      };

      return Texture;

    })();
    return exports.TextureCube = (function() {

      TextureCube.name = 'TextureCube';

      function TextureCube(paths) {
        var gl, i, _i,
          _this = this;
        this.paths = paths;
        gl = exports.context.gl;
        this.texture = gl.createTexture();
        this.texImages = new Array;
        this.loadedTextures = 0;
        for (i = _i = 0; _i <= 5; i = ++_i) {
          this.texImages[i] = new Image();
          exports.context.resources++;
          this.texImages[i].cubeID = i;
          this.texImages[i].onload = function() {
            var j, _j;
            _this.loadedTextures++;
            exports.context.resources--;
            if (_this.loadedTextures === 6) {
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, _this.texture);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              for (j = _j = 0; _j <= 5; j = ++_j) {
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _this.texImages[j]);
              }
              return gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            }
          };
          this.texImages[i].src = this.paths[i];
        }
      }

      TextureCube.prototype.bind = function() {
        var gl;
        gl = exports.context.gl;
        return gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
      };

      TextureCube.prototype.unbind = function() {
        var gl;
        gl = exports.context.gl;
        return gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
      };

      return TextureCube;

    })();
  });

}).call(this);
