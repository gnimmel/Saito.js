// http://www.gamedev.net/topic/560501-glsl-2d-metaballs--antialiasing/

#ifdef GL_ES
precision highp float;
#endif

varying vec2 vTextureCoord;
varying vec4 vTransformedNormal;

varying vec3 vNormal;
varying float vColor;

uniform vec2 resolution;
uniform vec4 mouse;

// Metaballs
uniform vec2 metaball0;
uniform vec2 metaball1;
uniform vec2 metaball2;
uniform vec2 metaball3;

uniform float metaballS0;
uniform float metaballS1;
uniform float metaballS2;
uniform float metaballS3;

const float aa_th = 1.01; //range for antialiasing
const float max_th = 0.99; //threshold
const float smoothMult = 1.0/(aa_th-max_th);


float calcMetaBalls(vec2 pos){
    //first metaball with radius 0.3

    float val =  metaballS0 / distance(pos, metaball0);
    val +=  metaballS1 / distance(pos, metaball1);
    val +=  metaballS2 / distance(pos, metaball2);
    val +=  metaballS3 / distance(pos, metaball3);

    val += 0.1 / distance(pos, mouse.xy/resolution.xy*2.0-1.0);
    return val;
}



void main(void) {
    vec2 screenPos = ((gl_FragCoord.xy / resolution.xy)*2.0-1.0);
    float val = 0.0;
    float temp = calcMetaBalls(screenPos);

    //thresholding

    if(temp<max_th){
       val = 1.0;
    } else {

      //this is a hacky approach to antialiase them. it works great
      //on the mainpart of the metaballs but not on the parts connecting them,
      //where it gets kinda blurry.
      //I propably have to factor in the function of their energy, but how?

      if(temp<aa_th){
       val = smoothstep(0.0, 1.0, (aa_th-temp)*smoothMult);
      } else {
       val = 0.0;
      }
    }
    gl_FragColor = vec4(val,val,val,1.0);
}